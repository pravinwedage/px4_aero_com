// Generated by gencpp from file px4_command/ControlParameterRequest.msg
// DO NOT EDIT!


#ifndef PX4_COMMAND_MESSAGE_CONTROLPARAMETERREQUEST_H
#define PX4_COMMAND_MESSAGE_CONTROLPARAMETERREQUEST_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace px4_command
{
template <class ContainerAllocator>
struct ControlParameterRequest_
{
  typedef ControlParameterRequest_<ContainerAllocator> Type;

  ControlParameterRequest_()
    : controllername()
    , dronemass(0.0)
    , cablelength(0.0)
    , a_j(0.0)
    , payloadmass(0.0)
    , motor_slope(0.0)
    , motor_intercept(0.0)
    , num_drone(0)
    , isPubAuxiliaryState(false)
    , isAddonForcedUsed(false)
    , isCrossFeedingTermsUsed(false)
    , t_jx(0.0)
    , t_jy(0.0)
    , t_jz(0.0)
    , kv_xy(0.0)
    , kv_z(0.0)
    , kR_xy(0.0)
    , kR_z(0.0)
    , kL(0.0)
    , Kphi_xy(0.0)
    , Kphi_z(0.0)
    , kr1_x(0.0)
    , kr1_y(0.0)
    , kr1_z(0.0)
    , kr2_x(0.0)
    , kr2_y(0.0)
    , kr2_z(0.0)
    , kp_x(0.0)
    , kp_y(0.0)
    , kp_z(0.0)
    , komega_x(0.0)
    , komega_y(0.0)
    , komega_z(0.0)
    , lambdaj_x(0.0)
    , lambdaj_y(0.0)
    , lambdaj_z(0.0)
    , lambda_T_x(0.0)
    , lambda_T_y(0.0)
    , lambda_T_z(0.0)
    , lambda_R_x(0.0)
    , lambda_R_y(0.0)
    , lambda_R_z(0.0)
    , lambda1_x(0.0)
    , lambda1_y(0.0)
    , lambda1_z(0.0)
    , lambda2_x(0.0)
    , lambda2_y(0.0)
    , lambda2_z(0.0)
    , pxy_error_max(0.0)
    , pz_error_max(0.0)
    , pxy_int_max(0.0)
    , pz_int_max(0.0)
    , tilt_max(0.0)
    , int_start_error(0.0)
    , fp_max_x(0.0)
    , fp_max_y(0.0)
    , fp_max_z(0.0)  {
    }
  ControlParameterRequest_(const ContainerAllocator& _alloc)
    : controllername(_alloc)
    , dronemass(0.0)
    , cablelength(0.0)
    , a_j(0.0)
    , payloadmass(0.0)
    , motor_slope(0.0)
    , motor_intercept(0.0)
    , num_drone(0)
    , isPubAuxiliaryState(false)
    , isAddonForcedUsed(false)
    , isCrossFeedingTermsUsed(false)
    , t_jx(0.0)
    , t_jy(0.0)
    , t_jz(0.0)
    , kv_xy(0.0)
    , kv_z(0.0)
    , kR_xy(0.0)
    , kR_z(0.0)
    , kL(0.0)
    , Kphi_xy(0.0)
    , Kphi_z(0.0)
    , kr1_x(0.0)
    , kr1_y(0.0)
    , kr1_z(0.0)
    , kr2_x(0.0)
    , kr2_y(0.0)
    , kr2_z(0.0)
    , kp_x(0.0)
    , kp_y(0.0)
    , kp_z(0.0)
    , komega_x(0.0)
    , komega_y(0.0)
    , komega_z(0.0)
    , lambdaj_x(0.0)
    , lambdaj_y(0.0)
    , lambdaj_z(0.0)
    , lambda_T_x(0.0)
    , lambda_T_y(0.0)
    , lambda_T_z(0.0)
    , lambda_R_x(0.0)
    , lambda_R_y(0.0)
    , lambda_R_z(0.0)
    , lambda1_x(0.0)
    , lambda1_y(0.0)
    , lambda1_z(0.0)
    , lambda2_x(0.0)
    , lambda2_y(0.0)
    , lambda2_z(0.0)
    , pxy_error_max(0.0)
    , pz_error_max(0.0)
    , pxy_int_max(0.0)
    , pz_int_max(0.0)
    , tilt_max(0.0)
    , int_start_error(0.0)
    , fp_max_x(0.0)
    , fp_max_y(0.0)
    , fp_max_z(0.0)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _controllername_type;
  _controllername_type controllername;

   typedef float _dronemass_type;
  _dronemass_type dronemass;

   typedef float _cablelength_type;
  _cablelength_type cablelength;

   typedef float _a_j_type;
  _a_j_type a_j;

   typedef float _payloadmass_type;
  _payloadmass_type payloadmass;

   typedef float _motor_slope_type;
  _motor_slope_type motor_slope;

   typedef float _motor_intercept_type;
  _motor_intercept_type motor_intercept;

   typedef int32_t _num_drone_type;
  _num_drone_type num_drone;

   typedef uint8_t _isPubAuxiliaryState_type;
  _isPubAuxiliaryState_type isPubAuxiliaryState;

   typedef uint8_t _isAddonForcedUsed_type;
  _isAddonForcedUsed_type isAddonForcedUsed;

   typedef uint8_t _isCrossFeedingTermsUsed_type;
  _isCrossFeedingTermsUsed_type isCrossFeedingTermsUsed;

   typedef float _t_jx_type;
  _t_jx_type t_jx;

   typedef float _t_jy_type;
  _t_jy_type t_jy;

   typedef float _t_jz_type;
  _t_jz_type t_jz;

   typedef float _kv_xy_type;
  _kv_xy_type kv_xy;

   typedef float _kv_z_type;
  _kv_z_type kv_z;

   typedef float _kR_xy_type;
  _kR_xy_type kR_xy;

   typedef float _kR_z_type;
  _kR_z_type kR_z;

   typedef float _kL_type;
  _kL_type kL;

   typedef float _Kphi_xy_type;
  _Kphi_xy_type Kphi_xy;

   typedef float _Kphi_z_type;
  _Kphi_z_type Kphi_z;

   typedef float _kr1_x_type;
  _kr1_x_type kr1_x;

   typedef float _kr1_y_type;
  _kr1_y_type kr1_y;

   typedef float _kr1_z_type;
  _kr1_z_type kr1_z;

   typedef float _kr2_x_type;
  _kr2_x_type kr2_x;

   typedef float _kr2_y_type;
  _kr2_y_type kr2_y;

   typedef float _kr2_z_type;
  _kr2_z_type kr2_z;

   typedef float _kp_x_type;
  _kp_x_type kp_x;

   typedef float _kp_y_type;
  _kp_y_type kp_y;

   typedef float _kp_z_type;
  _kp_z_type kp_z;

   typedef float _komega_x_type;
  _komega_x_type komega_x;

   typedef float _komega_y_type;
  _komega_y_type komega_y;

   typedef float _komega_z_type;
  _komega_z_type komega_z;

   typedef float _lambdaj_x_type;
  _lambdaj_x_type lambdaj_x;

   typedef float _lambdaj_y_type;
  _lambdaj_y_type lambdaj_y;

   typedef float _lambdaj_z_type;
  _lambdaj_z_type lambdaj_z;

   typedef float _lambda_T_x_type;
  _lambda_T_x_type lambda_T_x;

   typedef float _lambda_T_y_type;
  _lambda_T_y_type lambda_T_y;

   typedef float _lambda_T_z_type;
  _lambda_T_z_type lambda_T_z;

   typedef float _lambda_R_x_type;
  _lambda_R_x_type lambda_R_x;

   typedef float _lambda_R_y_type;
  _lambda_R_y_type lambda_R_y;

   typedef float _lambda_R_z_type;
  _lambda_R_z_type lambda_R_z;

   typedef float _lambda1_x_type;
  _lambda1_x_type lambda1_x;

   typedef float _lambda1_y_type;
  _lambda1_y_type lambda1_y;

   typedef float _lambda1_z_type;
  _lambda1_z_type lambda1_z;

   typedef float _lambda2_x_type;
  _lambda2_x_type lambda2_x;

   typedef float _lambda2_y_type;
  _lambda2_y_type lambda2_y;

   typedef float _lambda2_z_type;
  _lambda2_z_type lambda2_z;

   typedef float _pxy_error_max_type;
  _pxy_error_max_type pxy_error_max;

   typedef float _pz_error_max_type;
  _pz_error_max_type pz_error_max;

   typedef float _pxy_int_max_type;
  _pxy_int_max_type pxy_int_max;

   typedef float _pz_int_max_type;
  _pz_int_max_type pz_int_max;

   typedef float _tilt_max_type;
  _tilt_max_type tilt_max;

   typedef float _int_start_error_type;
  _int_start_error_type int_start_error;

   typedef float _fp_max_x_type;
  _fp_max_x_type fp_max_x;

   typedef float _fp_max_y_type;
  _fp_max_y_type fp_max_y;

   typedef float _fp_max_z_type;
  _fp_max_z_type fp_max_z;





  typedef boost::shared_ptr< ::px4_command::ControlParameterRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::px4_command::ControlParameterRequest_<ContainerAllocator> const> ConstPtr;

}; // struct ControlParameterRequest_

typedef ::px4_command::ControlParameterRequest_<std::allocator<void> > ControlParameterRequest;

typedef boost::shared_ptr< ::px4_command::ControlParameterRequest > ControlParameterRequestPtr;
typedef boost::shared_ptr< ::px4_command::ControlParameterRequest const> ControlParameterRequestConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::px4_command::ControlParameterRequest_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::px4_command::ControlParameterRequest_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::px4_command::ControlParameterRequest_<ContainerAllocator1> & lhs, const ::px4_command::ControlParameterRequest_<ContainerAllocator2> & rhs)
{
  return lhs.controllername == rhs.controllername &&
    lhs.dronemass == rhs.dronemass &&
    lhs.cablelength == rhs.cablelength &&
    lhs.a_j == rhs.a_j &&
    lhs.payloadmass == rhs.payloadmass &&
    lhs.motor_slope == rhs.motor_slope &&
    lhs.motor_intercept == rhs.motor_intercept &&
    lhs.num_drone == rhs.num_drone &&
    lhs.isPubAuxiliaryState == rhs.isPubAuxiliaryState &&
    lhs.isAddonForcedUsed == rhs.isAddonForcedUsed &&
    lhs.isCrossFeedingTermsUsed == rhs.isCrossFeedingTermsUsed &&
    lhs.t_jx == rhs.t_jx &&
    lhs.t_jy == rhs.t_jy &&
    lhs.t_jz == rhs.t_jz &&
    lhs.kv_xy == rhs.kv_xy &&
    lhs.kv_z == rhs.kv_z &&
    lhs.kR_xy == rhs.kR_xy &&
    lhs.kR_z == rhs.kR_z &&
    lhs.kL == rhs.kL &&
    lhs.Kphi_xy == rhs.Kphi_xy &&
    lhs.Kphi_z == rhs.Kphi_z &&
    lhs.kr1_x == rhs.kr1_x &&
    lhs.kr1_y == rhs.kr1_y &&
    lhs.kr1_z == rhs.kr1_z &&
    lhs.kr2_x == rhs.kr2_x &&
    lhs.kr2_y == rhs.kr2_y &&
    lhs.kr2_z == rhs.kr2_z &&
    lhs.kp_x == rhs.kp_x &&
    lhs.kp_y == rhs.kp_y &&
    lhs.kp_z == rhs.kp_z &&
    lhs.komega_x == rhs.komega_x &&
    lhs.komega_y == rhs.komega_y &&
    lhs.komega_z == rhs.komega_z &&
    lhs.lambdaj_x == rhs.lambdaj_x &&
    lhs.lambdaj_y == rhs.lambdaj_y &&
    lhs.lambdaj_z == rhs.lambdaj_z &&
    lhs.lambda_T_x == rhs.lambda_T_x &&
    lhs.lambda_T_y == rhs.lambda_T_y &&
    lhs.lambda_T_z == rhs.lambda_T_z &&
    lhs.lambda_R_x == rhs.lambda_R_x &&
    lhs.lambda_R_y == rhs.lambda_R_y &&
    lhs.lambda_R_z == rhs.lambda_R_z &&
    lhs.lambda1_x == rhs.lambda1_x &&
    lhs.lambda1_y == rhs.lambda1_y &&
    lhs.lambda1_z == rhs.lambda1_z &&
    lhs.lambda2_x == rhs.lambda2_x &&
    lhs.lambda2_y == rhs.lambda2_y &&
    lhs.lambda2_z == rhs.lambda2_z &&
    lhs.pxy_error_max == rhs.pxy_error_max &&
    lhs.pz_error_max == rhs.pz_error_max &&
    lhs.pxy_int_max == rhs.pxy_int_max &&
    lhs.pz_int_max == rhs.pz_int_max &&
    lhs.tilt_max == rhs.tilt_max &&
    lhs.int_start_error == rhs.int_start_error &&
    lhs.fp_max_x == rhs.fp_max_x &&
    lhs.fp_max_y == rhs.fp_max_y &&
    lhs.fp_max_z == rhs.fp_max_z;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::px4_command::ControlParameterRequest_<ContainerAllocator1> & lhs, const ::px4_command::ControlParameterRequest_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace px4_command

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::px4_command::ControlParameterRequest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::px4_command::ControlParameterRequest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::px4_command::ControlParameterRequest_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::px4_command::ControlParameterRequest_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::px4_command::ControlParameterRequest_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::px4_command::ControlParameterRequest_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::px4_command::ControlParameterRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ebfb0198b02485c9a6ec17f0c11eda7a";
  }

  static const char* value(const ::px4_command::ControlParameterRequest_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xebfb0198b02485c9ULL;
  static const uint64_t static_value2 = 0xa6ec17f0c11eda7aULL;
};

template<class ContainerAllocator>
struct DataType< ::px4_command::ControlParameterRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "px4_command/ControlParameterRequest";
  }

  static const char* value(const ::px4_command::ControlParameterRequest_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::px4_command::ControlParameterRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string controllername\n"
"float32 dronemass\n"
"float32 cablelength\n"
"float32 a_j\n"
"float32 payloadmass\n"
"float32 motor_slope\n"
"float32 motor_intercept \n"
"int32 num_drone\n"
"bool isPubAuxiliaryState\n"
"bool isAddonForcedUsed\n"
"bool isCrossFeedingTermsUsed\n"
"float32 t_jx\n"
"float32 t_jy\n"
"float32 t_jz\n"
"float32 kv_xy\n"
"float32 kv_z\n"
"float32 kR_xy\n"
"float32 kR_z\n"
"float32 kL\n"
"float32 Kphi_xy\n"
"float32 Kphi_z\n"
"float32 kr1_x\n"
"float32 kr1_y\n"
"float32 kr1_z\n"
"float32 kr2_x\n"
"float32 kr2_y\n"
"float32 kr2_z\n"
"float32 kp_x\n"
"float32 kp_y\n"
"float32 kp_z\n"
"float32 komega_x\n"
"float32 komega_y\n"
"float32 komega_z\n"
"float32 lambdaj_x\n"
"float32 lambdaj_y\n"
"float32 lambdaj_z\n"
"float32 lambda_T_x\n"
"float32 lambda_T_y\n"
"float32 lambda_T_z\n"
"float32 lambda_R_x\n"
"float32 lambda_R_y\n"
"float32 lambda_R_z\n"
"float32 lambda1_x\n"
"float32 lambda1_y\n"
"float32 lambda1_z\n"
"float32 lambda2_x\n"
"float32 lambda2_y\n"
"float32 lambda2_z\n"
"float32 pxy_error_max\n"
"float32 pz_error_max\n"
"float32 pxy_int_max\n"
"float32 pz_int_max\n"
"float32 tilt_max\n"
"float32 int_start_error\n"
"float32 fp_max_x\n"
"float32 fp_max_y\n"
"float32 fp_max_z\n"
;
  }

  static const char* value(const ::px4_command::ControlParameterRequest_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::px4_command::ControlParameterRequest_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.controllername);
      stream.next(m.dronemass);
      stream.next(m.cablelength);
      stream.next(m.a_j);
      stream.next(m.payloadmass);
      stream.next(m.motor_slope);
      stream.next(m.motor_intercept);
      stream.next(m.num_drone);
      stream.next(m.isPubAuxiliaryState);
      stream.next(m.isAddonForcedUsed);
      stream.next(m.isCrossFeedingTermsUsed);
      stream.next(m.t_jx);
      stream.next(m.t_jy);
      stream.next(m.t_jz);
      stream.next(m.kv_xy);
      stream.next(m.kv_z);
      stream.next(m.kR_xy);
      stream.next(m.kR_z);
      stream.next(m.kL);
      stream.next(m.Kphi_xy);
      stream.next(m.Kphi_z);
      stream.next(m.kr1_x);
      stream.next(m.kr1_y);
      stream.next(m.kr1_z);
      stream.next(m.kr2_x);
      stream.next(m.kr2_y);
      stream.next(m.kr2_z);
      stream.next(m.kp_x);
      stream.next(m.kp_y);
      stream.next(m.kp_z);
      stream.next(m.komega_x);
      stream.next(m.komega_y);
      stream.next(m.komega_z);
      stream.next(m.lambdaj_x);
      stream.next(m.lambdaj_y);
      stream.next(m.lambdaj_z);
      stream.next(m.lambda_T_x);
      stream.next(m.lambda_T_y);
      stream.next(m.lambda_T_z);
      stream.next(m.lambda_R_x);
      stream.next(m.lambda_R_y);
      stream.next(m.lambda_R_z);
      stream.next(m.lambda1_x);
      stream.next(m.lambda1_y);
      stream.next(m.lambda1_z);
      stream.next(m.lambda2_x);
      stream.next(m.lambda2_y);
      stream.next(m.lambda2_z);
      stream.next(m.pxy_error_max);
      stream.next(m.pz_error_max);
      stream.next(m.pxy_int_max);
      stream.next(m.pz_int_max);
      stream.next(m.tilt_max);
      stream.next(m.int_start_error);
      stream.next(m.fp_max_x);
      stream.next(m.fp_max_y);
      stream.next(m.fp_max_z);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ControlParameterRequest_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::px4_command::ControlParameterRequest_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::px4_command::ControlParameterRequest_<ContainerAllocator>& v)
  {
    s << indent << "controllername: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.controllername);
    s << indent << "dronemass: ";
    Printer<float>::stream(s, indent + "  ", v.dronemass);
    s << indent << "cablelength: ";
    Printer<float>::stream(s, indent + "  ", v.cablelength);
    s << indent << "a_j: ";
    Printer<float>::stream(s, indent + "  ", v.a_j);
    s << indent << "payloadmass: ";
    Printer<float>::stream(s, indent + "  ", v.payloadmass);
    s << indent << "motor_slope: ";
    Printer<float>::stream(s, indent + "  ", v.motor_slope);
    s << indent << "motor_intercept: ";
    Printer<float>::stream(s, indent + "  ", v.motor_intercept);
    s << indent << "num_drone: ";
    Printer<int32_t>::stream(s, indent + "  ", v.num_drone);
    s << indent << "isPubAuxiliaryState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isPubAuxiliaryState);
    s << indent << "isAddonForcedUsed: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isAddonForcedUsed);
    s << indent << "isCrossFeedingTermsUsed: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isCrossFeedingTermsUsed);
    s << indent << "t_jx: ";
    Printer<float>::stream(s, indent + "  ", v.t_jx);
    s << indent << "t_jy: ";
    Printer<float>::stream(s, indent + "  ", v.t_jy);
    s << indent << "t_jz: ";
    Printer<float>::stream(s, indent + "  ", v.t_jz);
    s << indent << "kv_xy: ";
    Printer<float>::stream(s, indent + "  ", v.kv_xy);
    s << indent << "kv_z: ";
    Printer<float>::stream(s, indent + "  ", v.kv_z);
    s << indent << "kR_xy: ";
    Printer<float>::stream(s, indent + "  ", v.kR_xy);
    s << indent << "kR_z: ";
    Printer<float>::stream(s, indent + "  ", v.kR_z);
    s << indent << "kL: ";
    Printer<float>::stream(s, indent + "  ", v.kL);
    s << indent << "Kphi_xy: ";
    Printer<float>::stream(s, indent + "  ", v.Kphi_xy);
    s << indent << "Kphi_z: ";
    Printer<float>::stream(s, indent + "  ", v.Kphi_z);
    s << indent << "kr1_x: ";
    Printer<float>::stream(s, indent + "  ", v.kr1_x);
    s << indent << "kr1_y: ";
    Printer<float>::stream(s, indent + "  ", v.kr1_y);
    s << indent << "kr1_z: ";
    Printer<float>::stream(s, indent + "  ", v.kr1_z);
    s << indent << "kr2_x: ";
    Printer<float>::stream(s, indent + "  ", v.kr2_x);
    s << indent << "kr2_y: ";
    Printer<float>::stream(s, indent + "  ", v.kr2_y);
    s << indent << "kr2_z: ";
    Printer<float>::stream(s, indent + "  ", v.kr2_z);
    s << indent << "kp_x: ";
    Printer<float>::stream(s, indent + "  ", v.kp_x);
    s << indent << "kp_y: ";
    Printer<float>::stream(s, indent + "  ", v.kp_y);
    s << indent << "kp_z: ";
    Printer<float>::stream(s, indent + "  ", v.kp_z);
    s << indent << "komega_x: ";
    Printer<float>::stream(s, indent + "  ", v.komega_x);
    s << indent << "komega_y: ";
    Printer<float>::stream(s, indent + "  ", v.komega_y);
    s << indent << "komega_z: ";
    Printer<float>::stream(s, indent + "  ", v.komega_z);
    s << indent << "lambdaj_x: ";
    Printer<float>::stream(s, indent + "  ", v.lambdaj_x);
    s << indent << "lambdaj_y: ";
    Printer<float>::stream(s, indent + "  ", v.lambdaj_y);
    s << indent << "lambdaj_z: ";
    Printer<float>::stream(s, indent + "  ", v.lambdaj_z);
    s << indent << "lambda_T_x: ";
    Printer<float>::stream(s, indent + "  ", v.lambda_T_x);
    s << indent << "lambda_T_y: ";
    Printer<float>::stream(s, indent + "  ", v.lambda_T_y);
    s << indent << "lambda_T_z: ";
    Printer<float>::stream(s, indent + "  ", v.lambda_T_z);
    s << indent << "lambda_R_x: ";
    Printer<float>::stream(s, indent + "  ", v.lambda_R_x);
    s << indent << "lambda_R_y: ";
    Printer<float>::stream(s, indent + "  ", v.lambda_R_y);
    s << indent << "lambda_R_z: ";
    Printer<float>::stream(s, indent + "  ", v.lambda_R_z);
    s << indent << "lambda1_x: ";
    Printer<float>::stream(s, indent + "  ", v.lambda1_x);
    s << indent << "lambda1_y: ";
    Printer<float>::stream(s, indent + "  ", v.lambda1_y);
    s << indent << "lambda1_z: ";
    Printer<float>::stream(s, indent + "  ", v.lambda1_z);
    s << indent << "lambda2_x: ";
    Printer<float>::stream(s, indent + "  ", v.lambda2_x);
    s << indent << "lambda2_y: ";
    Printer<float>::stream(s, indent + "  ", v.lambda2_y);
    s << indent << "lambda2_z: ";
    Printer<float>::stream(s, indent + "  ", v.lambda2_z);
    s << indent << "pxy_error_max: ";
    Printer<float>::stream(s, indent + "  ", v.pxy_error_max);
    s << indent << "pz_error_max: ";
    Printer<float>::stream(s, indent + "  ", v.pz_error_max);
    s << indent << "pxy_int_max: ";
    Printer<float>::stream(s, indent + "  ", v.pxy_int_max);
    s << indent << "pz_int_max: ";
    Printer<float>::stream(s, indent + "  ", v.pz_int_max);
    s << indent << "tilt_max: ";
    Printer<float>::stream(s, indent + "  ", v.tilt_max);
    s << indent << "int_start_error: ";
    Printer<float>::stream(s, indent + "  ", v.int_start_error);
    s << indent << "fp_max_x: ";
    Printer<float>::stream(s, indent + "  ", v.fp_max_x);
    s << indent << "fp_max_y: ";
    Printer<float>::stream(s, indent + "  ", v.fp_max_y);
    s << indent << "fp_max_z: ";
    Printer<float>::stream(s, indent + "  ", v.fp_max_z);
  }
};

} // namespace message_operations
} // namespace ros

#endif // PX4_COMMAND_MESSAGE_CONTROLPARAMETERREQUEST_H
